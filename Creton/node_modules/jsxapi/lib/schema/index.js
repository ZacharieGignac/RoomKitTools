"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generate = exports.parse = void 0;
var nodes_1 = require("./nodes");
function parseEventType(type, path) {
    switch (type) {
        case 'int':
            return new nodes_1.Plain('number');
        case 'literal':
        case 'string':
            return new nodes_1.Plain('string');
        default:
            throw new Error("Invalid Event type: " + type);
    }
}
function parseValueSpace(valuespace, path) {
    switch (valuespace.type) {
        case 'Integer':
            return new nodes_1.Plain('number');
        case 'IntegerArray':
            return new nodes_1.Plain('number[]');
        case 'String':
            return new nodes_1.Plain('string');
        case 'StringArray':
            return new nodes_1.Plain('string[]');
        case 'Literal':
        case 'LiteralArray':
            if (!valuespace.Value) {
                throw new Error('Missing literal valuespace values');
            }
            if (!valuespace.Value.length) {
                throw new Error('Empty literal valuespace values');
            }
            var vs = new (nodes_1.Literal.bind.apply(nodes_1.Literal, __spreadArray([void 0], valuespace.Value, false)))();
            return valuespace.type === 'LiteralArray' ? new nodes_1.List(vs) : vs;
        default:
            throw new Error("Invalid ValueSpace type: " + valuespace.type);
    }
}
function isCommandLeaf(value) {
    return !!value && value.command === 'True';
}
function isEventLeaf(value) {
    return 'type' in value;
}
function isLeaf(value) {
    return 'ValueSpace' in value;
}
function isAttr(key) {
    return !!key.match(/^[a-z]/);
}
function forEachEntries(schema, visitor) {
    Object.entries(schema)
        .filter(function (_a) {
        var key = _a[0];
        return !isAttr(key);
    })
        .forEach(function (_a) {
        var key = _a[0], value = _a[1];
        return visitor(key, value);
    });
}
function parseParameters(command, path) {
    var params = [];
    forEachEntries(command, function (key, value) {
        var fullPath = path.concat(key);
        try {
            var ps = Array.isArray(value) ? value[0] : value;
            var valuespace = parseValueSpace(ps.ValueSpace, fullPath);
            var required = ps.required === 'True';
            params.push(new nodes_1.Member(key, valuespace, { required: required }));
        }
        catch (error) {
            console.error("warning: '" + fullPath.join('/') + "' error parsing valuespace: " + error);
        }
    });
    return params;
}
function parseCommandTree(root, schema, tree, path) {
    forEachEntries(schema, function (key, value) {
        if (isCommandLeaf(value)) {
            var fullPath = path.concat(key);
            var params = parseParameters(value, fullPath);
            var paramsType = !params.length
                ? undefined
                : root.addInterface(fullPath.join('') + "Args");
            if (paramsType) {
                paramsType.addChildren(params);
            }
            tree.addChild(new nodes_1.Command(key, paramsType, undefined, {
                docstring: value.description || '',
                multiline: !!value.multiline && value.multiline === 'True',
            }));
        }
        else {
            var subTree = tree.addChild(new nodes_1.Tree(key));
            parseCommandTree(root, value, subTree, path.concat(key));
        }
    });
}
function parseConfigTree(root, schema, tree, path) {
    forEachEntries(schema, function (key, value) {
        var fullPath = path.concat(key);
        if (isLeaf(value)) {
            var vs = parseValueSpace(value.ValueSpace, fullPath);
            tree.addChild(new nodes_1.Member(key, vs, { docstring: value.description || '' }));
        }
        else if (Array.isArray(value)) {
            var subTree = tree.addChild(new nodes_1.Tree(key));
            for (var _i = 0, value_1 = value; _i < value_1.length; _i++) {
                var each = value_1[_i];
                var id = each.id;
                var idTree = subTree.addChild(new nodes_1.Tree(id));
                parseConfigTree(root, each, idTree, path.concat([key, id]));
            }
        }
        else {
            var subTree = tree.addChild(new nodes_1.Tree(key));
            parseConfigTree(root, value, subTree, path.concat(key));
        }
    });
}
function parseEventTree(root, schema, tree, path) {
    forEachEntries(schema, function (key, value) {
        var fullPath = path.concat(key);
        if (isEventLeaf(value)) {
            var vs = parseEventType(value.type, fullPath);
            tree.addChild(new nodes_1.Member(key, vs, { docstring: value.description || '' }));
        }
        else if (Array.isArray(value)) {
            var subTree = tree.addChild(new nodes_1.ArrayTree(key));
            for (var _i = 0, value_2 = value; _i < value_2.length; _i++) {
                var item = value_2[_i];
                parseEventTree(root, item, subTree, path.concat([key]));
            }
        }
        else {
            var subTree = tree.addChild(new nodes_1.Tree(key));
            parseEventTree(root, value, subTree, path.concat(key));
        }
    });
}
function parseStatusTree(root, schema, tree, path) {
    forEachEntries(schema, function (key, value) {
        var fullPath = path.concat(key);
        if (isLeaf(value)) {
            var vs = parseValueSpace(value.ValueSpace, fullPath);
            tree.addChild(new nodes_1.Member(key, vs, { docstring: value.description || '' }));
        }
        else if (Array.isArray(value)) {
            if (value.length !== 1) {
                throw new Error("error: " + fullPath.join('/') + " contains multiple entries");
            }
            var subTree = tree.addChild(new nodes_1.ArrayTree(key));
            parseStatusTree(root, value[0], subTree, path.concat([key]));
        }
        else {
            var subTree = tree.addChild(new nodes_1.Tree(key));
            parseStatusTree(root, value, subTree, path.concat(key));
        }
    });
}
function parseSchema(type, root, schema, parser) {
    var _a = {
        Command: {
            mkType: function (t) { return t; },
            rootKey: 'Command',
        },
        Config: {
            mkType: function (t) { return new nodes_1.Generic('Configify', t); },
            rootKey: 'Configuration',
        },
        Event: {
            mkType: function (t) { return new nodes_1.Generic('Eventify', t); },
            rootKey: 'Event',
        },
        Status: {
            mkType: function (t) { return new nodes_1.Generic('Statusify', t); },
            rootKey: 'StatusSchema',
        },
    }[type], rootKey = _a.rootKey, mkType = _a.mkType;
    var subSchema = schema[rootKey];
    if (!subSchema) {
        return;
    }
    if (typeof subSchema !== 'object') {
        throw new Error("schema." + type + " is not an object");
    }
    var tree = root.addInterface(type + "Tree");
    root.getMain().addChild(new nodes_1.Member(type, mkType(tree)));
    parser(root, subSchema, tree, [type]);
}
function parse(schema, options) {
    if (options === void 0) { options = {}; }
    var opts = __assign({ access: 'public-api', role: 'Admin', withConnect: true, xapiImport: 'jsxapi' }, options);
    var root = new nodes_1.Root(opts.xapiImport);
    root.addMain(opts.mainClass, { withConnect: opts.withConnect });
    root.addGenericInterfaces();
    parseSchema('Command', root, schema, parseCommandTree);
    parseSchema('Config', root, schema, parseConfigTree);
    parseSchema('Event', root, schema, parseEventTree);
    parseSchema('Status', root, schema, parseStatusTree);
    return root;
}
exports.parse = parse;
function generate(schema, options) {
    if (options === void 0) { options = {}; }
    var root = parse(schema, options);
    return root.serialize();
}
exports.generate = generate;
