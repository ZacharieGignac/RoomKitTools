"use strict";
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var duplex_passthrough_1 = __importDefault(require("duplex-passthrough"));
var ssh2_1 = require("ssh2");
var log_1 = __importDefault(require("../log"));
if (!duplex_passthrough_1.default.prototype.on.isPatched) {
    var origOn_1 = duplex_passthrough_1.default.prototype.on;
    var patchedFunc = function on() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        origOn_1.call.apply(origOn_1, __spreadArray([this], args, false));
        return this;
    };
    patchedFunc.isPatched = true;
    duplex_passthrough_1.default.prototype.on = patchedFunc;
    duplex_passthrough_1.default.prototype.addListener = patchedFunc;
}
function connectSSH(options) {
    var closing = false;
    var mergedOpts = Object.assign({
        client: new ssh2_1.Client(),
        transport: new duplex_passthrough_1.default(),
    }, options);
    var client = mergedOpts.client, password = mergedOpts.password, transport = mergedOpts.transport;
    delete mergedOpts.password;
    function onKeyboardInteractive(n, i, il, p, finish) {
        finish([password]);
    }
    function onReady() {
        log_1.default.debug('[SSH] connection ready');
        client.shell(false, function (err, sshStream) {
            if (err) {
                log_1.default.error('[SSH] shell error:', err);
                transport.emit('error', err);
                return;
            }
            log_1.default.debug('[SSH] shell ready');
            sshStream
                .on('error', function (error) {
                transport.emit('error', error);
            })
                .on('end', function () {
                if (!closing) {
                    transport.emit('error', 'Connection terminated remotely');
                }
            })
                .on('close', function () {
                transport.emit('close');
            });
            if (options.command) {
                client.exec(options.command, function (binaryErr, binaryStream) {
                    if (binaryErr) {
                        log_1.default.error('[SSH] exec error:', err);
                        transport.emit('error', binaryErr);
                        return;
                    }
                    binaryStream.on('error', function (error) {
                        log_1.default.error('[SSH] stream error:', error);
                        transport.emit('error', error);
                    });
                    log_1.default.debug('[SSH] exec ready');
                    transport.wrapStream(binaryStream);
                });
                return;
            }
            transport.wrapStream(sshStream);
        });
    }
    var agentSock = process.env.SSH_AUTH_SOCK;
    if (agentSock) {
        log_1.default.info("Using SSH agent socket \"" + agentSock + "\"");
        mergedOpts.agent = agentSock;
    }
    client
        .on('keyboard-interactive', onKeyboardInteractive)
        .on('ready', onReady)
        .on('error', function (error) {
        transport.emit('error', error.level);
    })
        .on('close', function () {
        transport.emit('close');
    })
        .connect(Object.assign({ tryKeyboard: true }, mergedOpts));
    transport.close = function () {
        closing = true;
        client.end();
    };
    return transport;
}
exports.default = connectSSH;
